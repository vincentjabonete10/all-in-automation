"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const driver_1 = __importDefault(require("lighthouse/lighthouse-core/gather/driver"));
const session_1 = __importDefault(require("lighthouse/lighthouse-core/fraggle-rock/gather/session"));
const page_functions_1 = __importDefault(require("lighthouse/lighthouse-core/lib/page-functions"));
const network_recorder_1 = __importDefault(require("lighthouse/lighthouse-core/lib/network-recorder"));
const installability_errors_1 = __importDefault(require("lighthouse/lighthouse-core/gather/gatherers/installability-errors"));
const web_app_manifest_1 = __importDefault(require("lighthouse/lighthouse-core/gather/gatherers/web-app-manifest"));
const link_elements_1 = __importDefault(require("lighthouse/lighthouse-core/gather/gatherers/link-elements"));
const viewport_dimensions_1 = __importDefault(require("lighthouse/lighthouse-core/gather/gatherers/viewport-dimensions"));
const collectMetaElements_1 = __importDefault(require("../scripts/collectMetaElements"));
const constants_1 = require("../constants");
class PWAGatherer {
    constructor(_session, _page) {
        this._session = _session;
        this._page = _page;
        this._networkRecords = [];
        this._frGatherer = new session_1.default(this._session);
        /**
         * setup network recorder
         */
        this._networkRecorder = new network_recorder_1.default();
        constants_1.NETWORK_RECORDER_EVENTS.forEach((method) => {
            this._session.on(method, (params) => this._networkRecorder.dispatch({ method, params }));
        });
        /**
         * setup LH driver
         */
        const connection = this._session;
        connection.sendCommand = (method, sessionId, ...paramAgrs) => this._session.send(method, ...paramAgrs);
        this._driver = new driver_1.default(connection);
        // @ts-ignore
        this._session['_connection']._transport._ws.addEventListener('message', (message) => this._driver._handleProtocolEvent(JSON.parse(message.data)));
        /**
         * clean up network records after every page load
         */
        this._page.on('load', () => {
            this._networkRecords = this._networkRecorder.getRawRecords();
            delete this._networkRecorder;
            this._networkRecorder = new network_recorder_1.default();
        });
    }
    async gatherData() {
        var _a;
        const pageUrl = await ((_a = this._page) === null || _a === void 0 ? void 0 : _a.url());
        const passContext = {
            url: pageUrl,
            driver: this._driver
        };
        const loadData = {
            networkRecords: this._networkRecords
        };
        const linkElements = new link_elements_1.default();
        const viewportDimensions = new viewport_dimensions_1.default();
        const { versions } = await this._driver.getServiceWorkerVersions();
        const { registrations } = await this._driver.getServiceWorkerRegistrations();
        return {
            URL: { requestedUrl: pageUrl, finalUrl: pageUrl },
            WebAppManifest: await web_app_manifest_1.default.getWebAppManifest(this._frGatherer, pageUrl),
            InstallabilityErrors: await installability_errors_1.default.getInstallabilityErrors(this._frGatherer),
            MetaElements: await this._driver.evaluate(collectMetaElements_1.default, {
                args: [],
                useIsolation: true,
                deps: [page_functions_1.default.getElementsInDocument],
            }),
            ViewportDimensions: await viewportDimensions.afterPass(passContext),
            ServiceWorker: { versions, registrations },
            LinkElements: await linkElements.afterPass(passContext, loadData)
        };
    }
}
exports.default = PWAGatherer;
